#!/bin/bash
# (C) 2012..2016, "Yann E. MORIN" <yann.morin.1998@free.fr>
# License: at your option, either one of: GPLv2 or GPLv3,
# see LICENSE.GPLv2 and LICENSE.GPLv3 in this repository
#
# Script to send a git pull-request, followed by the patches
# in a threaded way:
# [PATCH 0/X] Pull-request for branch XXXX
#   [PATCH 1/X] Subject for patch 1
#   [PATCH 2/X] Subject for patch 2
#   ...
#
# How to use:
#   - put this script in your PATH
#   - name it git-send-pull-request (or anything you fancy that
#     starts with 'git-', so git finds it).
#   - set it to be executable
#   - then call it with git:
#       git send-pull-request <START> <URL> [END] [--to TO|--cc CC|--bcc BCC] [OPTIONS]
#   - for more help, run:
#       git-send-pull-request --help
#
# Inspired by a script by Thomas PETAZZONI <thomas.petazzoni@free-electrons.com>
# (expecially the git commands to use), but entirely written from scratch by
# "Yann E. MORIN".

set -E
set -o pipefail

myname="${0##*/}"

#----------------------------------------------------------------------------
do_error() {
    local fmt="${1}"
    shift

    printf "%s: " "${myname}"
    printf "${fmt}" "${@}"
    exit 1
}

debug() { :; }
if [ -n "${GIT_DEBUG}" ]; then
    debug() {
        local fmt="${1}"
        shift

        printf "%s: " "${myname}" >&2
        printf "${fmt}" "${@}"  >&2
    }
fi

do_help() {
    cat <<-_EOF_
		Usage: ${myname} <start> <url> [end] [options]
		
		Options specific to ${myname}:
		
		    --version N
		                Specify this is version (iteration) 'N' of the
		                series. The cover-letter subbject will include
		                this number in the [PATCH 0/X vn] header, and
		                the cover-letter will include a section 'Changes
		                vn-1 -> vn'
		
		    --[no-]series
		                Do [do not] send the patch series as a follow-up of
		                the cover-letter. Default is to send the series.
		
		    --[not-]pull
		                Do [do not] make it a pull-request, just send a
		                cover-letter and the associated patches, so Patchwork
		                does not catch it up. Default is to send a pull-request.
		
		    --[no-]patchwork
		                Tell Patchwork to ignore / not to ignore the patches.
		                --no-patchwork implies --not-pull.
		                By default, tell Patchwork not to ignore them.
		
		    --cover-subject SUBJECT
		                Specify the subject for the cover-letter.
		                If not specified with --not-pull, it will be prompted for.
		                If specified with --pull, it overrides the default
		                subject 'Pull request for branch BRANCH'
		
		    --subject-suffix SUFFIX
		                Append 'SUFFIX' to the end of the part of the subject
		                between square-brackets. Eg. [PATCH n/N SUFFIX].
		                This is done for the cover letter as well as for each
		                individual patch.
		
		    --cover-to RCPT
		    --cover-cc RCPT
		    --cover-bcc RCPT
		                Add 'RCPT' as TO, CC, or BCC for the cover-letter
		                only, not individual patches.
		
		    --cover-cc-all
		                Add CC recipients to cover letter from the SoB-lines
	                    of individual patches.
		                Usefull to keep patches recipients aware of the
		                cover-letter, without sending them all the patches.
		
		    --dry-run
		                Do not actually send the mails and keep the temporary
		                directory for later manual inspection (to debug).
		
		Options can also be any option valid for 'git send-email', for
		example: --to, --cc, --bcc. Do not specify --compose, it is
		implicit: an editor will always be launched for you to review
		and edit the pull-request cover-letter.
		
		Note: at least one recipient must be specified (with any of --to
		or --cc).
	_EOF_
}

#----------------------------------------------------------------------------
# Parse args

# need to handle '--help' and '--compose' early
for arg; do
    case "${arg}" in
        # git will not call us if '--help' is the sole argument passed on
        # the command line, but does call us if '-h' is given. Weird... :-/
        --help|-h)
            do_help
            exit 0
            ;;
        # '--compose' is impolicit with send-pull-request, so it is not
        # possible to specify it.
        --compose)
            do_error "'--compose' is not compatible with send-pull-request\n"
            ;;
    esac
done

if [ ${#} -lt 2 ]; then
    do_help
    exit 1
fi

debug "Parsing args\n"
start="${1}"
url="${2}"
shift 2

case "${1}" in
    --*)
        debug "Looking for current local branch (end not given)\n"
        end="$( LANG= LC_ALL=C git branch                        \
                |sed -r -e '/^\*[[:space:]](.+)$/!d; s//\1/g;'   \
                        -e '/^\(no branch\)$/d'
              )"
        ;;
    "")
        do_help
        exit 1
        ;;
    *)
        end="${1}"
        shift 1
        ;;
esac

debug "Triaging args\n"
declare -a args_se
declare -a args_se_cover
declare -a cover_to
declare -a cover_cc
declare -a cover_bcc
no_series=0
no_pw=0
version=
cover_cc_all=0
is_pull=1
dry_run=0
while [ ${#} -ne 0 ]; do
    case "${1}" in
        --dry-run)
            dry_run=1
            ;;
        --series)
            no_series=0
            ;;
        --no-series)
            no_series=1
            ;;
        --version=*|-v=*)
            version="${1#*=}"
            ;;
        --version|-v)
            version="${2}"
            shift
            ;;
        --pull)
            is_pull=1
            ;;
        --not-pull)
            is_pull=0
            ;;
        --patchwork)
            no_pw=0
            ;;
        --no-patchwork)
            no_pw=1
            ;;
        --subject-suffix=*)
            subject_suffix="${1#*=}"
            ;;
        --subject-suffix)
            subject_suffix="${2}"
            shift
            ;;
        --cover-subject=*)
            cover_subject="${1#*=}"
            ;;
        --cover-to=*)
            cover_to+=( "${1#*=}" )
            ;;
        --cover-cc=*)
            cover_cc+=( "${1#*=}" )
            ;;
        --cover-bcc=*)
            cover_bcc+=( "${1#*=}" )
            ;;
        --cover-subject)
            cover_subject="${2}"
            shift
            ;;
        --cover-to)
            cover_to+=( "${2}" )
            shift
            ;;
        --cover-cc)
            cover_cc+=( "${2}" )
            shift
            ;;
        --cover-bcc)
            cover_bcc+=( "${2}" )
            shift
            ;;
        --cover-cc-all)
            cover_cc_all=1
            ;;
        *)
            args_se+=( "${1}" )
            ;;
    esac
    shift
done

debug "Checking if we have arguments for send-email\n"
if [ ${#args_se[@]} -lt 2 ]; then
    do_error "not enough arguments left for send-email\n"
fi
debug "Remaining arguments for send-email: '%s'\n" "${args_se[*]}"

#----------------------------------------------------------------------------
# Check args

if [ ${no_pw} -eq 1 ]; then
    is_pull=0
fi

debug "Checking if start '%s' is valid\n" "${start}"
if ! git rev-parse --verify "${start}" >/dev/null 2>&1; then
    do_error "start '%s' is not valid\n" "${start}"
    exit 1
fi

debug "Checking if end '%s' is valid\n" "${end:-(empty)}"
if [ -z "${end}" ] || ! git rev-parse --verify "${end}" >/dev/null 2>&1; then
    do_error "unknown branch '%s', or not on a branch\n" "${end:-(empty)}"
fi
if [ "${end}" = "master" ]; then
    do_error "end is 'master'; surely you do not want that, do you?\n"
fi

debug "Checking if url '%s' is valid\n" "${url}"
case "${url}" in
    git://*)    ;;
    http://*)   ;;
    https://*)  ;;
    *)  # Check if this is the name of a remote
        debug "\`--> It is not; maybe it's a remote name\n"
        debug "Checking if remote '%s' is valid\n" "${url}"
        url2="$( git remote show "${url}" 2>/dev/null                    \
                 |sed -r -e '/^[[:space:]]*Fetch URL: (.+)$/!d; s//\1/;' \
                 || true                                                 \
               )"
        debug "'%s' is url '%s'\n" "${url}" "${url2}"
        case "${url2}" in
            git://*)    ;;
            http://*)   ;;
            https://*)  ;;
            *)
                do_error "'%s': not a publicly-accessible repository\n" "${url}"
                ;;
        esac
        url="${url2}"
        ;;
esac

debug "Checking if url '%s' is reachable\n" "${url}"
if ! git ls-remote --heads "${url}" >/dev/null 2>/dev/null; then
    do_error "'%s': non-existing or unreachable repository\n" "${url}"
fi

debug "Checking if end '%s' exists on url '%s'\n" "${end}" "${url}"
remote_test="$( git ls-remote --heads "${url}" "${end}" 2>/dev/null )"
if [ -z "${remote_test}" ]; then
    do_error "'%s': no such branch on '%s'\n" "${end}" "${url}"
fi

debug "Checking if remote '%s' is the same as local '%s'\n" "${end}" "${end}"
local_hash="$( git log -n 1 --pretty=tformat:%H "${end}" )"
remote_hash="$( sed -r -e 's/[[:space:]].+//;' <<<"${remote_test}" )"
if [ "${local_hash}" != "${remote_hash}" ]; then
    do_error "'%s': remote hash %7.7s, local hash %7.7s\n" \
             "${end}" "${remote_hash}" "${local_hash}"
fi

# Check we have a proper subject for the cover-letter
if [ -z "${cover_subject}" ]; then
    if [ ${is_pull} -eq 1 ]; then
        cover_subject="Pull request for branch ${end}"
    else
        read -p "Subject for cover-letter: " cover_subject
        if [ -z "${cover_subject}" ]; then
            do_error "you must provide a subject for the cover-letter\n"
        fi
    fi
fi
if [ ${is_pull} -eq 0 ]; then
    cover_subject="${cover_subject} (branch ${end})"
fi

#----------------------------------------------------------------------------
tmp_dir="$( mktemp -d "${TMPDIR:-/tmp}/git-send-pull-request.XXXXXX" )"
patches_dir="${tmp_dir}/patches"

debug "Generating path series '%s..%s'\n" "${start}" "${end}"
git format-patch -M -n --cover-letter --thread              \
                 -o "${patches_dir}" "${start}..${end}"     >/dev/null

if [ -n "${version}" ]; then
    for p in "${patches_dir}/"*.patch; do
        sed -r -i -e 's/^(Subject: \[[^]]+)(\].*)$/\1 v'"${version}"'\2/' "${p}"
    done
fi

{
    printf "GIT: vim: ft=mail\n"
    printf "GIT: Lines starting with 'GIT:' are ignored.\n"
    printf "GIT: If you want to abort, just save an empty message,\n"
    printf "GIT: or just leave it as-is, without modifications.\n"

    awk --assign is_pull=${is_pull} \
        '$1=="Subject:" { exit; }
         $1=="From:" && is_pull==0 { print "X-Patchwork-Hint: ignore"; }
         { print; }
        ' "${patches_dir}/0000-cover-letter.patch"

    printf "Subject: ["
    if [ ${is_pull} -eq 1 ]; then
        printf "pull request"
    else
        nb_patches=$( git log --oneline "${start}..${end}" |wc -l )
        printf "PATCH 0/%d" ${nb_patches}
    fi
    if [ -n "${version}" ]; then
        printf " v%d" ${version}
    fi
    printf "] %s \n\n" "${cover_subject}"

    printf "Hello All!\n\n"

    if [ -n "${version}" ]; then
        printf "\nChanges v%d -> v%d:\n  - \n\n" $((version-1)) ${version}
    fi
    printf "\n"

    user_name="$( git config --get user.name )"
    printf "Regards,\n%s.\n\n\n" "${user_name}"

    debug "Generating initial request-pull content\n"
    git request-pull "${start}" "${url}" "${end}"

    printf "\n%s \n" "--"
    if [ -f "${HOME}/.signature" ]; then
        cat "${HOME}/.signature"
    fi
} >"${patches_dir}/0000-cover-letter"
rm -f "${patches_dir}/0000-cover-letter.patch"

if [ -n "${subject_suffix}" ]; then
    debug "tweaking subject with '%s'\n" "${subject_suffix}"
    sed -r -i -e 's/^(Subject: \[[^]]+)]/\1 '"${subject_suffix}"']/' \
        "${patches_dir}/"*
fi

if [ ${no_pw} -eq 1 ]; then
    for p in "${patches_dir}/"*.patch; do
        mv "${p}" "${p}.tmp"
        awk --assign no_pw=${no_pw} \
             '$1=="From:" && no_pw==1 { no_pw=0; print "X-Patchwork-Hint: ignore"; }
              { print; }
             ' "${p}.tmp" >"${p}"
        rm -f "${p}.tmp"
    done
fi

old_sha1=$( sha1sum "${patches_dir}/0000-cover-letter"  \
            |cut -d ' ' -f 1
          )

debug "Launching editor '%s'\n" "${EDITOR:-vi}"
"${EDITOR:-vi}" "${patches_dir}/0000-cover-letter"

new_sha1=$( sha1sum "${patches_dir}/0000-cover-letter"  \
            |cut -d ' ' -f 1
          )

sed -r -i -e '/^GIT: /d' "${patches_dir}/0000-cover-letter"

if [    -s "${patches_dir}/0000-cover-letter"   \
     -a "${old_sha1}" != "${new_sha1}" ]; then

    if [ ${cover_cc_all} -eq 1 ]; then
        eval cover_cc+=\( $( sed -r -e '/^(Signed-off-by|Reported-by|CC|Cc): (.*)$/!d;' \
                                    -e 's//\x27\2\x27/;' "${patches_dir}/"*.patch       \
                             |sort -u                                                   ) \)
    fi
    for rcpt in "${cover_to[@]}"; do
        args_se_cover+=( --to "${rcpt}" )
    done
    for rcpt in "${cover_cc[@]}"; do
        args_se_cover+=( --cc "${rcpt}" )
    done
    for rcpt in "${cover_bcc[@]}"; do
        args_se_cover+=( --bcc "${rcpt}" )
    done

    debug "Asking smtp password\n"
    smpt_server="$( git config --get sendemail.smtpserver )"
    read -s -p "SMTP password ${smpt_server}: " smtppass
    printf "\n" # 'read -s' does not echo the \n at the end
                # of the prompt, so we need to do it ourselves.
    args_se+=( --smtp-pass="${smtppass}" )

    debug "Sending pull-request cover-letter:\n"
    for i in git send-email "${args_se[@]}" "${args_se_cover[@]}" "${patches_dir}/0000-cover-letter"; do
        debug "  - '%s'\n" "${i}"
    done
    if [ ${dry_run} -eq 0 ]; then
        git send-email "${args_se[@]}" "${args_se_cover[@]}" "${patches_dir}/0000-cover-letter"
    fi
    ret=${?}
    if [ ${ret} -eq 0 -a ${no_series} -eq 0 ]; then
        # git always sleeps a bit between to mails, to avoid
        # being caught as a spammer. Since our cover-letter and
        # series are sent with two deifferent git invocations,
        # we're missign a sleep in-between the cover-letter and
        # the patches.
        sleep 1
        debug "Sending patch series as reply to pull-request:\n"
        for i in git send-email --no-thread "${args_se[@]}" "${patches_dir}/"*.patch; do
            debug "  - '%s'\n" "${i}"
        done
        if [ ${dry_run} -eq 0 ]; then
            git send-email --no-thread "${args_se[@]}" "${patches_dir}/"*.patch
        else
            (exit 42) # For keep temporary directory and files
        fi
        ret=${?}
    fi
else
    printf "Empty or unmodified cover-letter. Aborting.\n"
    ret=0
fi

if [ ${ret} -eq 0 ]; then
    rm -rf "${tmp_dir}"
else
    printf "git-send-email failed with error code %d\n" ${ret}
    do_error "Your intro email has been kept as: %s\n" "${patches_dir}/0000-cover-letter"
fi
